#' Plotting the emission distribution for a fitted multilevel HMM
#'
#' \code{plot.mHMM_emiss} plots the emission probability distribution for
#' a fitted multilevel hidden Markov model.
#' The plotted emission probability distributions either represents
#' the probabilities at the group level, i.e., representing the average emission
#' probability distribution over all subjects, or at the subject level.
#' In case of the latter, the user has to specify for which subject the emission
#' probability matrix should be plotted.
#'
#'
#' @param x An object of class \code{mHMM_emiss}, generated by the function
#'   \code{\link{obtain_emiss}}.
#' @param subj_nr An integer specifying for which specific subject the
#'   transition probability matrix should be plotted. Only required if the input
#'   object represents the subject specific transition probability matrices.
#'@param by_state An optional logic variable. It indicates how user would like
#'           to display the plots. It is set to \code{TRUE} by default and it
#'           display plots state wise. If dependent variable wise presentation
#'           is preferred \code{by_state} should be set to \code{FALSE}
#'           (\code{by_state=FALSE})
#' @param dep_lab Optional vector of strings when plotting emission probability
#' distribution, denoting the labels of dependent variable. Length of the vector
#' need to be of the number of dependent variables in input object x. The first
#' position of the vector is a label of the first object in the input object x.
#' To provide only chosen labels user need to set the rest to \code{NA}.
#' When a position of the vector is set to \code{NA}, the label is generated from the
#' input object x. Labels are automatically obtained from the input object x
#' when not specified.
#' @param cat_lab optional list of n_dep(number of dependent variables) vectors
#' of strings when plotting emission probability distribution variables in input
#' object x. The first vector represents labels of the dependent variable's
#' categories which is listed first in the input object x. To provide only some
#' labels of dependent variables, user need to set the rest list elements to
#' \code{NA}. Labels are automatically obtained from the input object x when not
#' specified.
#' @param col An optional vector of the size of the number of categories of the
#'  dependent variable that has them the most,specifying the used colors in the
#'  \code{\link[graphics]{barplot}}.
#' @param legend_cex A numerical value giving the amount by which
#         plotting text and symbols in the legend should be magnified relative
#'        to the default.
#' @param ... Arguments to be passed to methods
#'            (see \code{\link[graphics]{barplot}})
#'
#'
#' @return \code{plot.mHMM_gamma} returns a plot of the emission probability
#'   matrix. Depending on whether the input object represents list of emission
#'   probability matrices at the group level or the subject specific list of
#'   emission probability matrices, the returned plot represents either
#'   the group emission probability distribution for each state, or the emission
#'   probability distribution for each state of given subject,
#'   specified by \code{subject_nr}.
#'
#' @seealso \code{\link{mHMM}} for fitting the multilevel hidden Markov
#'   model, creating the object \code{mHMM}, and \code{\link{obtain_emiss}} to
#'   obtain the transition probabilities gamma for a fitted multilevel HMM,
#'   creating the object \code{mHMM_gamma}.
#'
#' @examples
#' \donttest{
#' m <- 3 #number of states
#' n_dep <- 4 #number of dependent variables used to infer the hidden states
#' q_emiss <- c(3, 2, 3, 2) #number of categorical outcomes of
#'                           each of dependent variables
#' start_TM <- diag(.8, m) #transition matrix
#' start_TM
#' start_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2
#' start_EM <- list(matrix(c(0.05, 0.90, 0.05,
#'                           0.90, 0.05, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[2]), # looking patient
#'                 matrix(c(0.90, 0.05, 0.05,
#'                          0.05, 0.90, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[4])) # looking therapist
#'
#' out_3st <- mHMM(s_data = nonverbal,
#'                 gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
#'                 start_val = c(list(start_TM), start_EM),
#'                 mcmc = list(J = 10, burn_in = 5))
#'
#' # creating object of obtain_emiss class
#' group_emiss3<-obtain_emiss(out_3st,level = "group")
#'
#' subject_emiss3<-obtain_emiss(out_3st,level = "subject")
#'
#' #plotting
#' plot(x=subject_emiss3,subj_nr = 2)
#'
#' plot(x=group_emiss3)
#'
#' plot(x=group_emiss3,by_state=FALSE)
#'
#'
#'}
#'
#' @export

plot.mHMM_emiss<- function(x,subj_nr=NULL,by_state=TRUE,cat_lab,
                           dep_lab,col,cex=1,...){

#inside function checking if the list of class of x is nested (subject specific) or not(group specific)

  isNested <- function(x) {
    out <- FALSE
    strout <- utils::capture.output(str(x))
    idx <- grep("\\$.*List", strout)
    if (length(idx)) {
      out <- TRUE
    }
    return(out)
  }

  #-----Here the class checked
  if (!is.mHMM_emiss(x)){
    stop("The input object x should be from the class mHMM_emiss, obtained with the function obtain_emiss.")
  }

  # set to default plot space size
  k=c(5.1,4.1,4.1,2.1)
  par(mar=k)
  empty<-c()


  #number of dependent variables counted from number of elements of list x
  n_dep<-length(x)


  q_emiss<-c()
  m<-c()

  if (isNested(x)==T){

    if (is.null(subj_nr)){
      stop("When the input object x represents the subject specific transition
           probability matrices, the subject for which the probabilities should
           be plotted needs to be specified with the input variable -subj_nr-.")
    }else{
      new<-list()
      for(n in 1:n_dep){
        new[[n]]<-x[[n]][[subj_nr]]
        x[[n]]<-new[[n]]
      }



      #calculating m(number of states) and q_emiss(vector representing number of categories for each dep. variable) for subject level
      m<-dim(x[[1]])[1]

      for(b in 1:n_dep){
      q_emiss[b]<-dim(x[[b]])[2]
    }
  }

    }else{

    if(!is.null(subj_nr)){
      warning("The subject number can only be specified when plotting the subject level transition probabilities. Currently, the group level transition probabilities are plotted.")
    }

    #calculating m(number of states) and q_emiss(vector representing number of categories for each dep. variable) for subject level
    m<- dim(x[[1]])[1]

    for(l in 1:n_dep){
      q_emiss[l]<-dim(x[[l]])[2]
    }
    new<-list()
    new<-x

    }

  #Plugging specified by user dependent variable labels
  if(!missing(dep_lab) && length(dep_lab)==max(n_dep)){
    for (k in which(!is.na(dep_lab))) {
        names(x)[k]<-dep_lab[k]
      }

    }else if(!missing(dep_lab) && length(dep_lab)!=max(n_dep)){
    stop("When specifying group labels for the model the length of the vector
           has to be equal to the number of dependent variables.")
    }

  #Plugging specified by user category labels
  if (missing(cat_lab)==T){
    for(k in n_dep){
      colnames(new[[k]])<-colnames(new[[k]])
    }
    }else if(!missing(cat_lab) && is.list(cat_lab)==F){
      stop("The variable -cat_lab- has to be of a list type")
      }else if(length(cat_lab)!=n_dep){
          stop("The -cat_lab- need to contain n_dep(number of dependent variables)
           elements of lenght of number of cathegories for each of dependent
           variable")
    }

  if(!missing(cat_lab)){
    for(q in which(!is.na(cat_lab))){
      if(length(cat_lab[[q]])!=q_emiss[q]){
        stop("The vector length is not of the same lenght as the number of
              cathegories of ", q,"th dependent variable")
        }else{
          colnames(new[[q]]) <-cat_lab[[q]]
      }
      }
  }



  # Color setting
  if(missing(col)){

    n_col<- max(q_emiss)

    if("RColorBrewer" %in% (.packages())){
      set.seed(12399)
      qual_col_pals = RColorBrewer::brewer.pal.info[brewer.pal.info$category == 'qual',]
      col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
      coul<-sample(col_vector, n_col)
    }else{

      coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
    }
  }else if(!missing(col)){
    coul<-col
  }


  # --- by_state==TRUE meaning that the plots will be displayed for each state
  if(by_state==TRUE){

  emission_states<-list()
  data<-matrix(nrow=n_dep,ncol=max(q_emiss))
  for(s in 1:m){
    for(j in 1:n_dep){
      while(ncol(x[[j]])!=max(q_emiss)) x[[j]]<-cbind(x[[j]],0)
      data[j,]<-x[[j]][s,]
    }
    data<-as.data.frame(data)
    row.names(data)<-c(names(x))
    emission_states[[s]]<-as.data.frame(data)
    data<-matrix(nrow=n_dep,ncol=max(q_emiss))
  }
  a<-emission_states

  #Plotting grid setting
  if(m>3){
    pre_grid<-matrix(NA,5,ceiling(m/2))
    extra <-matrix(NA, 5, ceiling(m/4))

    pre_grid[1,]<-rep(ceiling(m/2)*2+ceiling(n_dep/4)*4+1,ceiling(m/2))
    pre_grid[2,]<-c(1:ceiling(m/2))
    pre_grid[3,]<-pre_grid[2,]
    pre_grid[4,]<-c((ceiling(m/2)+1):(ceiling(m/2)*2))
    pre_grid[5,]<-pre_grid[4,]

    for(i in 1:ceiling(n_dep/4)){

      extra[,i]<-c(ceiling(m/2)*2+ceiling(n_dep/4)*4+1,ceiling(m/2)*2+(i*4)-3
                   ,ceiling(m/2)*2+(i*4)-2,ceiling(m/2)*2+(i*4)-1,ceiling(m/2)*2+(i*4))
    }
    new_grid<-cbind(pre_grid,extra)


  }else{

    new_grid<-matrix(NA,1+n_dep, m+1)
    new_grid[1,]<-rep(m+n_dep+1,m+1)

    for (r in 1:n_dep+1) {
      new_grid[r,]<-c(1:m,m+r-1)
    }

    new_grid[1,]<-rep(m+n_dep+1,m+1)

  }
  graphics::layout(new_grid)

  #here we plot for only 3 states but if we will want to plot 5 then after m plots there has to be ceiling(m/2)*2-m more empty plots
  for(j in 1:m){
    if(is.null(subj_nr)==F){
      main_sub<-paste("Subject ",subj_nr)
      graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2,...)
    }
    else{
      graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2,...)
    }
  }
  if(m>3){
    empty<-((ceiling(m/2)*2)-m)
  while(empty>0){
    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    empty=empty-1
    }
  }

  old<-graphics::par("mai")
  graphics::par(mar=old)

  #there is ceiling(n_dep/4)*4 inputs so add ceiling(n_dep/4)*4-n_dep empty plots
  for(p in 1:n_dep){
    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    if(is.null(subj_nr)==F){
      graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n") #here I checked
    }else{
      graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n")
    }
  }

  if(m>3){
   empty<-((ceiling(n_dep/4)*4)-n_dep)
   while(empty>0) {
     graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
     empty=empty-1
    }
  }

  graphics::par(mar=old)

  graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
  if(is.null(subj_nr)==F){
    main_sub<-paste("subject ",subj_nr)
    graphics::text(x=1,y=0, paste("Emission probability distributions by states for",main_sub), cex = 2, col = "black")
  }else{
    graphics::text(x=1,y=0, paste("Group emission probability distributions by states"), cex = 2, col = "black")
    }
# Here when we want to plot grouping by dependent variable

  }else if(by_state==FALSE){

    if(n_dep>3){
       pre_grid<-matrix(NA,5,ceiling(n_dep/2))
       pre_grid[1,]<-rep(ceiling(n_dep/2)*2+ceiling(n_dep/4)*4+1,ceiling(n_dep/2))
       extra <-matrix(NA, 5, ceiling(n_dep/4))

       pre_grid[2,]<-c(1:ceiling(n_dep/2))
       pre_grid[3,]<-c(1:ceiling(n_dep/2))
       pre_grid[4,]<-c((ceiling(n_dep/2)+1):(ceiling(n_dep/2)*2))
       pre_grid[5,]<-c((ceiling(n_dep/2)+1):(ceiling(n_dep/2)*2))

       for(i in 1:ceiling(n_dep/4)){

         extra[,i]<-c(ceiling(n_dep/2)*2+ceiling(n_dep/4)*4+1,ceiling(n_dep/2)*2+(i*4)-3
                      ,ceiling(n_dep/2)*2+(i*4)-2,ceiling(n_dep/2)*2+(i*4)-1,ceiling(n_dep/2)*2+(i*4))
       }
       new_grid<-cbind(pre_grid,extra)

       }else{
         new_grid<-matrix(NA,1+n_dep, n_dep+1)
         new_grid[1,]<-rep((n_dep)*2+1,n_dep+1)
         for (r in 2:(1+n_dep)) {
           new_grid[r,]<-c(1:n_dep,n_dep+r-1)
      }
    }
    graphics::layout(new_grid)

    for(j in 1:n_dep){ #here we plot for only 3 states but if we will want to plot 5 then after m plots there has to be ceiling(m/2)*2-m more empty plots
      if(is.null(subj_nr)==F){
        main_sub<-paste("Subject ",subj_nr) # change the source of title
        graphics::barplot(t(x[[j]]),main=names(x)[j],yaxt="n",legend=F, col=coul,las=2,...)
      }
      else{
        graphics::barplot(t(x[[j]]),main=names(x)[j],yaxt="n",legend=F, col=coul,las=2,...)
      }
    }
  if(n_dep>3){
    empty<-((ceiling(n_dep/2)*2)-n_dep)
    while(empty>0) {
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      empty=empty-1
    }
  }
    old<-graphics::par("mai")
    graphics::par(mar=old)

    #there is ceiling(n_dep/4)*4 imputs so add ((ceiling(n_dep/4)*4)-n_dep) empty plots
    for(p in 1:n_dep){
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      if(is.null(subj_nr)==F){
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n")
      }else{
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n")
      }
    }
    if(n_dep>3){
     empty<-((ceiling(n_dep/4)*4)-n_dep)
    while(empty>0) {
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      empty=empty-1
    }
    }

    graphics::par(mar=old)

    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    if(is.null(subj_nr)==F){
      main_sub<-paste("subject ",subj_nr)
      graphics::text(x=1,y=0, paste("Emission probability distributions by dependent variables for",main_sub), cex = 2, col = "black")
    }else{
      graphics::text(x=1,y=0, paste("Group emission probability distributions by dependent variables"), cex = 2, col = "black")
      }
    }
  graphics::par(mfrow=c(1,1))
}

#plot(x=subject_emiss3,subj_nr = 2,by_state = F,col = c("red","orange","green"))
#plot(x=subject_emiss3,subj_nr = 3,by_state = T,col = c("red","orange","green"),
#     dep_lab=c("Patient Looking",NA,"Therapist Vocalizing","Therapist Looking"))
#plot(x=subject_emiss3,subj_nr = 7,by_state = T,col = c("red","orange","green"),
#     dep_lab=c("Patient Looking",NA,"Therapist Vocalizing","Therapist Looking"),cat_lab=list())
#plot(x=subject_emiss3,subj_nr = 7,by_state = T,col = c("red","orange","green"),dep_lab=c("Patient Looking",NA,"Therapist Vocalizing","Therapist Looking"),cat_lab=list(c("low","medium","high"),NA,NA,NA))








