#' Plotting the emission distribution for a fitted multilevel HMM
#'
#' \code{plot.mHMM_emiss} plots the emission probability distribution for
#' a fitted multilevel hidden Markov model.
#' The plotted emission probability distributions either represents
#' the probabilities at the group level, i.e., representing the average emission
#' probability distribution over all subjects, or at the subject level.
#' In case of the latter, the user has to specify for which subject the emission
#' probability matrix should be plotted.
#' @inheritParams plot.mHMM_gamma
#' @param x An object of class \code{mHMM_emiss}, generated by the function
#'   \code{\link{obtain_emiss}}.
#' @param q_emiss A vector of length \code{n_dep} representing numbers of
#' categorical outcomes for each of dependent variables.
#' @param group_labs An optional vector of length \code{n_dep} with names
#'                   for each dependent variable
#' @param cat_labs A list of length \code{n_dep} representing labels of
#'                 of categories for each of dependent variable. The list
#'                 consist of \code{n_dep} objects each being a vector
#'                 of size representing the number of dependent variables'
#'                 categories
#' @param by_state An optional logic variable. It indicates how user would like
#'           to display the plots. It is set to \code{TRUE} by default and it
#'           display plots state wise. If dependent variable wise presentation
#'           is prefered \code{by_state} should be set to \code{FALSE}
#'           (\code{by_state=FALSE})
#' @param col An optional vector of length \code{max(q_emiss)} (i.e., where
#'   \code{max(q_emiss)} denotes the number of categories of dependent variable
#'    with the most categories) specifying the used colors for the plot.
#'
#' @return \code{plot.mHMM_gamma} returns a plot of the emission probability
#'   matrix. Depending on whether the input object represents list of emission
#'   probability matrices at the group level or the subject specific list of
#'   emission probability matrices, the returned plot represents either
#'   the group emission probability distribution for each state, or the emission
#'   probability distribution for each state of given subject,
#'   specified by \code{subject_nr}.
#'
#' @seealso \code{\link{mHMM}} for fitting the multilevel hidden Markov
#'   model, creating the object \code{mHMM}, and \code{\link{obtain_emiss}} to
#'   obtain the transition probabilities gamma for a fitted multilevel HMM,
#'   creating the object \code{mHMM_gamma}.
#'
#' @examples
#' \donttest{
#' m <- 3 #number of states
#' n_dep <- 4 #number of dependent variables used to infer the hidden states
#' q_emiss <- c(3, 2, 3, 2) #number of categorical outcomes of
#'                           each of dependent variables
#' start_TM <- diag(.8, m) #transition matrix
#' start_TM
#' start_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2
#' start_EM <- list(matrix(c(0.05, 0.90, 0.05,
#'                           0.90, 0.05, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[2]), # looking patient
#'                 matrix(c(0.90, 0.05, 0.05,
#'                          0.05, 0.90, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[4])) # looking therapist
#'
#' out_3st <- mHMM(s_data = nonverbal,
#'                 gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
#'                 start_val = c(list(start_TM), start_EM),
#'                 mcmc = list(J = 10, burn_in = 5))
#'
#' # creating object of obtain_emiss class
#' group_emiss3<-obtain_emiss(out_3st,level = "group")
#'
#' subject_emiss3<-obtain_emiss(out_3st,level = "subject")
#'
#' # setting new dependent variables' labels
#' group_labs<-c("voc_pat","look_pat","voc_ther","look_ther")
#'
#' #plotting
#' plot(x=subject_emiss3, group_labs = group_labs,subj_nr = 2)
#'
#' plot(x=group_emiss3)
#'
#' plot(x=group_emiss3,group_labs=group_labs,by_state=FALSE)
#'
#'
#' }
#'
#' @export


plot.mHMM_emiss<- function(x,subj_nr=NULL,by_state=TRUE,group_labs,cat_labs,col){

#inside function checking if the list of class of x is nested (subject specific) or not(group specific)

  isNested <- function(x) {
    out <- FALSE
    strout <- capture.output(str(x))
    idx <- grep("\\$.*List", strout)
    if (length(idx)) {
      out <- TRUE
    }
    return(out)
  }

  #-----Here the class checked
  if (!is.mHMM_emiss(x)){
    stop("The input object x should be from the class mHMM_emiss, obtained with the function obtain_emiss.")
  }

  # set to default plot space size
  k=c(5.1,4.1,4.1,2.1)
  par(mar=k)
  empty<-c()


  #number of dependent variables counted from number of elements of list x
  n_dep<-length(x)


  q_emiss<-c()
  m<-c()

  if (isNested(x)==T){

    if (is.null(subj_nr)){
      stop("When the input object x represents the subject specific transition
           probability matrices, the subject for which the probabilities should
           be plotted needs to be specified with the input variable -subj_nr-.")
    }else{
      new<-vector(mode = "list", length = n_dep)
      for(n in 1:n_dep){
        new[[n]]<-x[[n]][[subj_nr]]
      }

      for (k in 1:n_dep) {
        x[[k]]<-new[[k]]

      }

      #calculating m(number of states) and q_emiss(vector representing number of categories for each dep. variable) for subject level
      m<-dim(x[[1]])[1]

      for(b in 1:n_dep){
      q_emiss[b]<-dim(x[[b]])[2]
    }
  }

    }else{

    if(!is.null(subj_nr)){
      warning("The subject number can only be specified when plotting the subject level transition probabilities. Currently, the group level transition probabilities are plotted.")
    }

    #calculating m(number of states) and q_emiss(vector representing number of categories for each dep. variable) for subject level
    m<- dim(x[[1]])[1]

    for(l in 1:n_dep){
      q_emiss[l]<-dim(x[[l]])[2]
    }
    new<-list()
    new<-x

    }
  group_labs<-vector(mode = "vector", length = n_dep)
  #Plugging specified by user dependent variable labels
  if(!missing(group_labs) && length(group_labs)==max(n_dep)){
    for (k in 1:n_dep) {
      if (group_labs==""){
        skip()
      }else{
        names(x)[k]<-group_labs[k]
      }

    }
    }else if(!missing(group_labs) && length(group_labs)!=max(n_dep)){
    stop("When specifying group labels for the model the length of the vector
           has to be equal to the number of dependent variables.")
    }

  #Plugging specified by user category labels
  if(!missing(cat_labs) && is.list(cat_labs)==F){
      stop("The variable -cat_labs- has to be of a list type")
    if(length(cat_labs)!=n_dep){
      stop("The -cat_labs- need to contain n_dep elements of lenght of number of
           cathegories for each of dependent variable")
    }

    for(q in 1:n_dep){
      if(length(cat_labs[[q]])!=q_emiss[q]){
        stop("The vector length is not of the same lenght as the number of cathegories of ", q,"th dependent variable")
      }else
        colnames(new[[q]])<-cat_labs[[q]]
    }
  }




  # Color setting
  if(missing(col)){

    n_col<- max(q_emiss)

    if("RColorBrewer" %in% (.packages())){
      set.seed(12399)
      qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
      col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
      coul<-sample(col_vector, n_col)
    }else{

      coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
    }
  }


  # --- by_state==TRUE meaning that the plots will be displayed for each state
  if(by_state==TRUE){

  emission_states<-list()
  data<-matrix(nrow=n_dep,ncol=max(q_emiss))
  for(s in 1:m){
    for(j in 1:n_dep){
      while(ncol(x[[j]])!=max(q_emiss)) x[[j]]<-cbind(x[[j]],0)
      data[j,]<-x[[j]][s,]
    }
    data<-as.data.frame(data)
    row.names(data)<-c(names(x))
    emission_states[[s]]<-as.data.frame(data)
    data<-matrix(nrow=n_dep,ncol=max(q_emiss))
  }
  a<-emission_states

  #Plotting grid setting
  if(m>3){
    pre_grid<-matrix(NA,5,ceiling(m/2))
    extra <-matrix(NA, 5, ceiling(m/4))

    pre_grid[1,]<-rep(ceiling(m/2)*2+ceiling(n_dep/4)*4+1,ceiling(m/2))
    pre_grid[2,]<-c(1:ceiling(m/2))
    pre_grid[3,]<-pre_grid[2,]
    pre_grid[4,]<-c((ceiling(m/2)+1):(ceiling(m/2)*2))
    pre_grid[5,]<-pre_grid[4,]

    for(i in 1:ceiling(n_dep/4)){

      extra[,i]<-c(ceiling(m/2)*2+ceiling(n_dep/4)*4+1,ceiling(m/2)*2+(i*4)-3
                   ,ceiling(m/2)*2+(i*4)-2,ceiling(m/2)*2+(i*4)-1,ceiling(m/2)*2+(i*4))
    }
    new_grid<-cbind(pre_grid,extra)


  }else{

    new_grid<-matrix(NA,1+n_dep, m+1)
    new_grid[1,]<-rep(m+n_dep+1,m+1)

    for (r in 1:n_dep+1) {
      new_grid[r,]<-c(1:m,m+r-1)
    }

    new_grid[1,]<-rep(m+n_dep+1,m+1)

  }
  graphics::layout(new_grid)

  #here we plot for only 3 states but if we will want to plot 5 then after m plots there has to be ceiling(m/2)*2-m more empty plots
  for(j in 1:m){
    if(is.null(subj_nr)==F){
      main_sub<-paste("Subject ",subj_nr)
      graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2)
    }
    else{
      graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2)
    }
  }
  if(m>3){
    empty<-((ceiling(m/2)*2)-m)
  while(empty>0){
    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    empty=empty-1
    }
  }

  old<-graphics::par("mai")
  graphics::par(mar=old)

  #there is ceiling(n_dep/4)*4 inputs so add ceiling(n_dep/4)*4-n_dep empty plots
  for(p in 1:n_dep){
    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    if(is.null(subj_nr)==F){
      graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =1,bty="n") #here I checked
    }else{
      graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =1,bty="n")
    }
  }

  if(m>3){
   empty<-((ceiling(n_dep/4)*4)-n_dep)
   while(empty>0) {
     graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
     empty=empty-1
    }
  }

  graphics::par(mar=old)

  graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
  if(is.null(subj_nr)==F){
    main_sub<-paste("subject ",subj_nr)
    graphics::text(x=1,y=0, paste("Emission probability distributions by states for",main_sub), cex = 2, col = "black")
  }else{
    graphics::text(x=1,y=0, paste("Group emission probability distributions by states"), cex = 2, col = "black")
    }

  }else if(by_state==FALSE){
    if(n_dep>3){
       pre_grid<-matrix(NA,5,ceiling(n_dep/2))
       pre_grid[1,]<-rep(ceiling(n_dep/2)*2+ceiling(n_dep/4)*4+1,ceiling(n_dep/2))
       extra <-matrix(NA, 5, ceiling(n_dep/4))

       pre_grid[2,]<-c(1:ceiling(n_dep/2))
       pre_grid[3,]<-c(1:ceiling(n_dep/2))
       pre_grid[4,]<-c((ceiling(n_dep/2)+1):(ceiling(n_dep/2)*2))
       pre_grid[5,]<-c((ceiling(n_dep/2)+1):(ceiling(n_dep/2)*2))

       for(i in 1:ceiling(n_dep/4)){

         extra[,i]<-c(ceiling(n_dep/2)*2+ceiling(n_dep/4)*4+1,ceiling(n_dep/2)*2+(i*4)-3
                      ,ceiling(n_dep/2)*2+(i*4)-2,ceiling(n_dep/2)*2+(i*4)-1,ceiling(n_dep/2)*2+(i*4))
       }
       new_grid<-cbind(pre_grid,extra)

       }else{
         new_grid<-matrix(NA,1+n_dep, n_dep+1)
         new_grid[1,]<-rep((n_dep)*2+1,n_dep+1)
         for (r in 2:(1+n_dep)) {
           new_grid[r,]<-c(1:n_dep,n_dep+r-1)
      }
    }
    graphics::layout(new_grid)

    for(j in 1:n_dep){ #here we plot for only 3 states but if we will want to plot 5 then after m plots there has to be ceiling(m/2)*2-m more empty plots
      if(is.null(subj_nr)==F){
        main_sub<-paste("Subject ",subj_nr) # change the source of title
        graphics::barplot(t(x[[j]]),main=names(x)[j],yaxt="n",legend=F, col=coul,las=2)
      }
      else{
        graphics::barplot(t(x[[j]]),main=names(x)[j],yaxt="n",legend=F, col=coul,las=2)
      }
    }
  if(n_dep>3){
    empty<-((ceiling(n_dep/2)*2)-n_dep)
    while(empty>0) {
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      empty=empty-1
    }
  }
    old<-graphics::par("mai")
    graphics::par(mar=old)

    #there is ceiling(n_dep/4)*4 imputs so add ((ceiling(n_dep/4)*4)-n_dep) empty plots
    for(p in 1:n_dep){
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      if(is.null(subj_nr)==F){
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =1,bty="n")
      }else{
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =1,bty="n")
      }
    }
    if(n_dep>3){
     empty<-((ceiling(n_dep/4)*4)-n_dep)
    while(empty>0) {
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      empty=empty-1
    }
    }

    graphics::par(mar=old)

    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    if(is.null(subj_nr)==F){
      main_sub<-paste("subject ",subj_nr)
      graphics::text(x=1,y=0, paste("Emission probability distributions by dependent variables for",main_sub), cex = 2, col = "black")
    }else{
      graphics::text(x=1,y=0, paste("Group emission probability distributions by dependent variables"), cex = 2, col = "black")
      }
    }
  graphics::par(mfrow=c(1,1))
}
#i want to do a list that woul take the cathegory names from the lest that contains n_dep objects
