#' Plotting the emission distribution for a fitted multilevel HMM
#'
#' \code{plot.mHMM_emiss} plots the emission probability distribution for a fitted
#' multilevel hidden Markov model.
#' The plotted emission probability distributions either represents
#' the probabilities at the group level, i.e., representing the average emission
#' probability distribution over all subjects, or at the subject level.
#' In case of the latter, the user has to specify for which subject the emission
#' probability matrix should be plotted.
#'
#' @param emiss An object of class \code{mHMM_emiss}, generated by the function
#'   \code{\link{obtain_emiss}}.
#' @param n_dep A number of dependent variables used to infer the hidden states
#' @param q_emiss A vector of length \code{n_dep} representing numbers of
#' categorical outcomes for each of dependent variables.
#' @param m A number of hidden states
#' @param group_labs A vector of length \code{n_dep} with names for each
#' dependent variable
#' @param subj_nr An integer specifying for which specific subject the
#'   emission distribution should be plotted. Only required if the input
#'   object represents the subject specific list of emission matrices.
#' @param col An optional vector with length \code{max(q_emiss)} (i.e., where
#'   \code{max(q_emiss)} denotes the number of categories of dependent variable
#'    with the most categories) specifying the used colors for the plot.
#'
#' @return \code{plot.mHMM_gamma} returns a plot of the emission probability
#'   matrix. Depending on whether the input object represents list of emission
#'   probability matrices at the group level or the subject specific list of emission
#'   probability matrices, the returned plot represents either the group
#'   emission probability distribution for each state, or the emission probability
#'   distribution for each state of given subject, specified by \code{subject_nr}.
#'
#' @seealso \code{\link{mHMM}} for fitting the multilevel hidden Markov
#'   model, creating the object \code{mHMM}, and \code{\link{obtain_emiss}} to
#'   obtain the transition probabilities gamma for a fitted multilevel HMM,
#'   creating the object \code{mHMM_gamma}.
#'
#' @examples
#' \donttest{
#' m <- 3 #number of states
#' n_dep <- 4 #number of dependent variables used to infer the hidden states
#' q_emiss <- c(3, 2, 3, 2) #number of categorical outcomes of each of dependent variables
#' start_TM <- diag(.8, m) #transition matrix
#' start_TM
#' start_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2
#' start_EM <- list(matrix(c(0.05, 0.90, 0.05,
#'                           0.90, 0.05, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[2]), # looking patient
#'                 matrix(c(0.90, 0.05, 0.05,
#'                          0.05, 0.90, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[4])) # looking therapist
#'
#' out_3st <- mHMM(s_data = nonverbal, gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),start_val = c(list(start_TM), start_EM),mcmc = list(J = 100, burn_in = 5))
#'
#' group_emiss3<-obtain_emiss(out_3st,level = "group")
#' subject_emiss3<-obtain_emiss(out_3st,level = "subject")
#'
#' group_labs<-c("voc_patient","look_patient","voc_therapist","look_therapist")
#'
#' plot.mHMM_emiss(emiss=subject_emiss3,q_emiss =q_emiss,m=m,n_dep =n_dep,group_labs = group_labs,color = coul,nr_sub = 2)
#'
#' plot.mHMM_emiss(emiss=group_emiss3,q_emiss = q_emiss,m=m,n_dep=n_dep,group_labs = group_labs,color = coul)
#'
#'
#' }
#'
#' @export



plot.mHMM_emiss<- function(emiss,q_emiss,m,n_dep,group_labs,col,subj_nr=NULL){
  k=c(5.1,4.1,4.1,2.1)
  new_gr<-list()

  par(mar=k)

  isNested <- function(x) {
    out <- FALSE
    strout <- capture.output(str(x))
    idx <- grep("\\$.*List", strout)
    if (length(idx)) {
      out <- TRUE
    }
    return(out)
  }

  #-----Here the class checked
   if (!is.mHMM_emiss(emiss)){
    stop("The input object emiss should be from the class mHMM_emiss, obtained with the function obtain_emiss.")
  }

  if (isNested(emiss)==T){

    if (is.null(subj_nr)){
      stop("When the input object x represents the subject specific transition
           probability matrices, the subject for which the probabilities should
           be plotted needs to be specified with the input variable -subj_nr-.")
    }
    else{
      new<-list() #list to contain the emission probability matrices for each state
      for(n in 1:n_dep){
        new[[n]]<-emiss[[n]][[subj_nr]]
      }

      emiss=new

    }

  }else{

    if(!is.null(subj_nr)){
      warning("The subject number can only be specified when plotting the subject level transition probabilities. Currently, the group level transition probabilities are plotted.")
    }
    new_gr<-emiss

  }


  if(missing(col)){

    n_col<- max(q_emiss) #here you can add a number of categories you have got

    if("RColorBrewer" %in% (.packages())){
      set.seed(12399)
      qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
      col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
      coul<-sample(col_vector, n_col) # and here it is an array of colors created
    }else{

      coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
    }

  }
  emission_states<-list()
  data<-matrix(nrow=n_dep,ncol=max(q_emiss))
  for(s in 1:m){

    for(i in 1:n_dep){
      while(ncol(emiss[[i]])!=max(q_emiss)) emiss[[i]]<-cbind(emiss[[i]],0)
      data[i,]<-emiss[[i]][s,]
    }
    data<-as.data.frame(data)
    row.names(data)<-c(group_labs)
    emission_states[[s]]<-as.data.frame(data)
    data<-matrix(nrow=n_dep,ncol=max(q_emiss))
  }
  a<-emission_states
  #here I set up a grid
  new_grid<-matrix(NA,1+n_dep,m+1)
  new_grid[1,]<-rep(n_dep+m+1,m+1)
  for (r in 2:(1+n_dep)) {
    new_grid[r,]<-c(1:m,m+r-1)
  }

  layout(new_grid)
  for(j in 1:m){
    if(is.null(subj_nr)==F){
      main_sub<-paste("Subject ",subj_nr)
      x<-graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2)
      #text(seq(1,n_dep, by=1), par("usr")[3]-0.1, labels =group_labs, srt = -45, pos =1, xpd = TRUE)
    }
    else{
      x<-graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2)
      #text(seq(1,n_dep, by=1), par("usr")[3]-0.2, labels =group_labs, srt = -45, pos =1, xpd = TRUE)

    }

  }
  old<-par("mai")
  par(mar=old)
  for(p in 1:n_dep){
    plot(0,type='n',axes=FALSE,ann=FALSE)
    if(is.null(subj_nr)==F){

      legend("center",legend=colnames(new[[p]]),fill=coul,title=group_labs[p],cex =1) #I dont know why there is no title when I put names(new[p])
    }
    else{
      legend("center",legend=colnames(new_gr[[p]]),fill=coul,title=names(new_gr[p]),cex =1)

    }
  }
  par(mar=old)
  plot(0,type='n',axes=FALSE,ann=FALSE)
  if(is.null(subj_nr)==F){
    main_sub<-paste("subject ",subj_nr)
    text(x=1,y=0, paste("Emission probability distributions by states for",main_sub), cex = 2, col = "black")
  }else{
    text(x=1,y=0, paste("Group emission probability distributions by states"), cex = 2, col = "black")

  }
  par(mfrow=c(1,1))
}


