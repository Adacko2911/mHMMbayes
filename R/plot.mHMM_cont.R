#' Plotting the posterior densities for a fitted multilevel HMM
#'
#' \code{plot.mHMM_cont} plots the posterior densities for a fitted multilevel hidden
#' Markov model for the group and subject level parameters simultaneously. The
#' plotted posterior densities are either for the transition probability matrix
#' gamma, or for the emission distribution probabilities.
#'
#' @param x Object of class \code{mHMM_cont}, generated by the function
#'   \code{\link{mHMM}}.
#' @param component String specifying if the displayed posterior densities
#'   should be for the transition probability matrix gamma (\code{component =
#'   "gamma"}), or for the emission distribution probabilities (\code{component
#'   = "emiss"}). In case of the latter and the model is based on multiple
#'   dependent variables, the user has to indicate for which dependent variable
#'   the posterior densities have to be plotted, see \code{dep}.
#' @param dep Integer specifying for which dependent variable the posterior
#'   densities should be plotted. Only required if one wishes to plot the
#'   emission distribution probabilities and the model is based on multiple
#'   dependent variables.
#' @param  trace_plot A logical parameter set to \code{FALSE} by default.
#'   When set to \code{TRUE} the output
#'   is a set of trace plots for either emission probabilities when
#'   \code{component= "emiss"} or transition probabilities when \code{component= "gamma"}
#' @param col Vector of colors for the posterior density lines. If one is
#'   plotting the posterior densities for gamma, the vector has length \code{m}
#'   (i.e., number of hidden states). If one is plotting the posterior densities
#'   for the emission probabilities, the vector has length \code{q_emiss[k]}
#'   (i.e., the number of outcome categories for the dependent variable
#'   \code{k}).
#' @param dep_lab Optional vector of strings when plotting the posterior
#'   densities of the emission probabilities with length \code{n_dep}, denoting
#'   the labels of the dependent variables. Automatically obtained from the
#'   input object \code{x} when not specified.
#' @param lwd1 Positive number indicating the line width of the posterior
#'   density at the group level.
#' @param lwd2 Positive number indicating the line width of the posterior
#'   density at the subject level.
#' @param lty1 Positive number indicating the line type of the posterior
#'   density at the group level.
#' @param lty2 Positive number indicating the line type of the posterior
#'   density at the subject level.
#' @param burn_in An integer which specifies the number of iterations to discard
#'   when obtaining the model parameter summary statistics. When left
#'   unspecified, the burn in period specified at creating the \code{mHMM}
#'   object with the function \code{\link{mHMM}} will be used.
#' @param legend_cex A numerical value giving the amount by which plotting text
#'   and symbols in the legend should be magnified relative to the default.

#' @param ... Arguments to be passed to methods (see \code{\link[graphics]{par}})
#'
#' @return \code{plot.mHMM_cont} returns a plot of the posterior densities. Depending
#'   on whether (\code{component = "gamma"}) or (\code{component = "emiss"}),
#'   the plotted posterior densities are either for the transition probability
#'   matrix gamma or for the emission distribution probabilities, respectively.
#'
#' @seealso \code{\link{mHMM_cont}} for fitting the multilevel hidden Markov
#'   model, creating the object \code{mHMM_cont}.
#'
#' @examples
#' ###### First run the function mHMM on the nonverbal data
#' \donttest{
#' # specifying general model properties:
#' }
#'
#' @export
#'
plot.mHMM_cont <- function(x, component = "gamma", dep = 1, col,
                      dep_lab, lwd1 = 2, lwd2 = 1, lty1 = 1, lty2 = 3,
                      legend_cex, burn_in, trace_plot=FALSE ,...){

  object <- x
  input   <- x$input
  n_subj  <- input$n_subj
  m       <- input$m
  n_dep   <- input$n_dep

  if (!is.mHMM_cont(x)){
    stop("The input object x should be from the class mHMM_cont, obtained with the function mHMM_cont().")
  }
  if (component != "gamma" & component != "emiss"){
    stop("The input specified under component should be a string, restrectid to state either gamma or emiss.")
  }
  if(all(dep!=1:n_dep)==T){
    stop("_dep_ is a number representing  dependent variable. It has to be positive and cannot be grater then number of dependent variables _n_dep_.")
  }

  if (missing(burn_in)){
    burn_in <- input$burn_in
  }
  J       <- input$J
  if (burn_in >= (J-1)){
    stop(paste("The specified burn in period should be at least 2 points smaller
               compared to the number of iterations J, J =", J))
  }
  old_par <- graphics::par(no.readonly =TRUE)
  on.exit(graphics::par(old_par))

  if(component == "gamma"){
    if (missing(col)){
      state_col <- grDevices::rainbow(m)
    } else {
      state_col <- col
    }
    col_st<-rep(state_col,m)

    if(trace_plot==T){

      graphics::par(mfrow = c(m,m),mar = c(4,3,3,1) + 0.1, mgp = c(2.2,1,0))
      labels<-c()
      for (k in 1:m) {
        for (l in 1:m) {
          labels<-c(labels,paste("From state ",k, "to state ",l))
        }
      }
      for(i in 1:m^2){
        median<-median(object$gamma_prob_bar[,i])
        graphics::plot(x = 1:J, y = object$gamma_prob_bar[,i],
                       ylim = c(0,1), las=1, type = "l", ylab = "Transition probability",
                       xlab = "Iteration", main = labels[i],lwd = lwd1, lty = lty1,
                       col=col_st[i])
        graphics::abline(h=median,lwd = lwd1)
      }
    }else{

    if(m > 3){
      graphics::par(mfrow = c(2,ceiling(m/2)), mar = c(4,3,2,1) + 0.1, mgp = c(2,1,0))
    } else {
      graphics::par(mfrow = c(1,m), mar = c(4,3,2,1) + 0.1, mgp = c(2,1,0))
    }
    for(i in 1:m){
      max <- 0
      for(l in 1:m){
        new <- max(stats::density(object$gamma_prob_bar[burn_in:J, m * (i-1) + l])$y)
        if(new > max){max <- new}
      }
      graphics::plot.default(x = 1, ylim = c(0, max), xlim = c(0,1), type = "n", cex = .8,  main =
                               paste("From state", i, "to state ..."),las=1, ylab = "",
                             xlab = "Transition probability", ,yaxt = "n",...)
      graphics::title(ylab="Density", line=.5)
      for(j in 1:m){
        graphics::lines(stats::density(object$gamma_prob_bar[burn_in:J,m * (i-1) + j]),
                        type = "l", col = state_col[j], lwd = lwd1, lty = lty1)
        for(s in 1:n_subj){
          graphics::lines(stats::density(object$PD_subj[[s]][burn_in:J,(sum(n_dep * m)*2+ m * (i-1) + j)]),
                          type = "l", col = state_col[j], lwd = lwd2, lty = lty2)
        }
      }
      graphics::legend("topright", col = state_col, legend = paste("To state", 1:m),
                       bty = 'n', lty = 1, lwd = 2, cex = .8)
    }
    }
  } else if (component == "emiss"){

    if(all(dep!=1:n_dep)==T){
      stop("_dep_ is a number representing  dependent variable. It has to be positive and cannot be grater then number of dependent variables _n_dep_.")
    }


      if (missing(dep_lab)){
      dep_lab <- input$dep_labels[dep]
    } else {
      if (!is.vector(dep_lab) | length(dep_lab) != n_dep){
        stop(paste0("dep_lab should be a vector with lenght n_dep (", n_dep, ")"))
      }
      dep_lab <- dep_lab[dep]
    }
    max<-0
    for(k in 1:m){
      ylim_prep<-density(object$emiss_mu_bar[[dep]][(1+burn_in):J,k])$y
      ylim1<-max(ylim_prep)
      if(ylim1>max){max<-ylim1}
    }

    xlim2<-max(object$emiss_mu_bar[[dep]][-c(1:burn_in),])
    xlim1<-min(object$emiss_mu_bar[[dep]][-c(1:burn_in),])
    column_PD_subj<-seq(1:m)+m*(dep-1)

    if (missing(col)){
      state_col <- grDevices::rainbow(m)
    } else {
      state_col <- col
    }
    if(trace_plot==TRUE){

      var_data<-object$emiss_var_bar[[dep]][-1,]
      sd_data<-sqrt(var_data)
      max1<-max(object$emiss_mu_bar[[dep]][,1:m])
      min1<-min(object$emiss_mu_bar[[dep]][,1:m])
      max2<-max(sd_data)
      min2<-min(sd_data)

      graphics::par(mfrow = c(2,m), mar = c(4,3,3,1) + 0.1, mgp = c(2.2,1,0))
      for(q in 1:m){
        median_mean<-median(object$emiss_mu_bar[[dep]][,q])
        graphics::plot.default(x = 1:J, y = object$emiss_mu_bar[[dep]][,q],las=1, type = "l",
                             ylim=c(min1,max1),lwd = lwd1, lty = lty1,
                             main = paste(dep_lab, ", State ", q),
                             xlab = "Iteration", ylab="Mean",col=state_col[q])
        graphics::abline(h=median_mean, lwd=2)
      }

      for(k in 1:m){
        # add density curve for population level posterior distribution
        median_sd<-median(sd_data[,k])
        graphics::plot(x=1:(J-1),sd_data[,k], las=1,
                        type = "l", lwd = lwd1, lty = lty1,
                       ylim=c(min2,max2),
                       main = paste(dep_lab, ", State ", k),
                       xlab = "Iteration", ylab="Standard deviation",col=state_col[k])
        graphics::abline(h=median_sd,lwd=2)
      }

    }else{
      # set plotting area
      graphics::par(mfrow = c(1,2), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))


      graphics::plot.default(x = 1, ylim = c(0, max+0.1), xlim = c(xlim1-0.1,xlim2+0.1), type = "n",
                             main = paste(dep_lab, "mean distribution"),
                             yaxt = "n", ylab = "", xlab = "mean ", ...)
      graphics::title(ylab="Density", line=.5)
      for(q in 1:m){
        # add density curve for population level posterior distribution
        graphics::lines(stats::density(object$emiss_mu_bar[[dep]][(1+burn_in):J,q]),
                        type = "l", col = state_col[q], lwd = lwd1, lty = lty1)
        # add density curves for subject posterior distributions
        for(s in 1:n_subj){
          graphics::lines(stats::density(object$PD_subj[[s]][(1+burn_in):J,column_PD_subj[q]]),
                          type = "l", col = state_col[q], lwd = lwd2, lty = lty2)
        }
      }
      graphics::legend("topright", col = state_col, legend =paste("State", 1:m) , bty = 'n', lty = 1, lwd = 2, cex = .7)



      var_data<-object$emiss_var_bar[[dep]][-1,]
      sd_data<-sqrt(var_data)

      xlim1_2<-min(sd_data[-c(1:burn_in-1),])
      xlim2_2<-max(sd_data[-c(1:burn_in-1),])
      max<-0
      for(k in 1:m){
        ylim_prep<-density(sd_data[,k])$y
        ylim1<-max(ylim_prep)
        if(ylim1>max){max<-ylim1}
      }
      graphics::plot.default(x = 1, ylim = c(0, max+0.1), xlim = c(xlim1_2-0.1,xlim2_2+0.1), type = "n",
                             main = paste(dep_lab, "stadard deviation distributions"),
                             yaxt = "n", ylab = "", xlab = "standard deviation ", ...)
      graphics::title(ylab="Density", line=.5)

      for(q in 1:m){
        # add density curve for population level posterior distribution
        graphics::lines(stats::density(sd_data[burn_in:J-1,q]),
                        type = "l", col = state_col[q], lwd = lwd1, lty = lty1)
      }
      graphics::legend("topright", col = state_col, legend =paste("State", 1:m) , bty = 'n', lty = 1, lwd = 2, cex = .7)
}
    }
  }


